import java.util.ArrayList;
import java.util.Calendar;
import java.util.GregorianCalendar;

/**
 * The AppointmentBook class is a wrapper class for the Appointment class.
 * It acts as a management class for multiple appointments grouped together.
 * @author midmandle
 *
 */

public class AppointmentBook {
	int NOTFOUND = 0;
	int FOUND = 1;
	int NO_TIME_CLASH = 0;
	int TIME_CLASH = -1;
	
	String appointmentBookName;
	
	ArrayList<Appointment> appointmentList = new ArrayList<Appointment>();
	
	/**
	 * Constructor for the AppointmentBook object. Requires a name for the AppointmentBook
	 * so that in the event of multiple AppointmentBook objects they can be logically
	 * distinguished from one another by the user.
	 * @param appointmentBookName The logical name of the newly created AppointmentBook object.
	 */
	public AppointmentBook(String appointmentBookName)
	{
		
		this.appointmentBookName = appointmentBookName;
		boolean exists = DatabaseCommunicator.CheckIfAppointmentBookExistsOnDatabase(appointmentBookName);
		
		if(exists)
		{
			intialiseAppointmentBookFromDatabase();
		}
		else
		{
			System.out.println("Ping");
			DatabaseCommunicator.SetupNewAppointmentBookForDatabase(appointmentBookName);
		}
	}
	
	/**
	 * Adds a new Appointment object to the appointmentList maintained by the AppointmentBook class.
	 * @param newAppointment The new Appointment object to add.
	 * @return Returns an integer value depending on if the new Appointment object was successfully added to the AppointmentBook.
	 * If the Appointment to add already exists then a positive value will be returned. If the new Appointment clashes with an exiting
	 * appointment then a -1 negative value will be returne. If appointment is added successfully then a 0 is returned.
	 */
	public int add(Appointment newAppointment)
	{
		if(isInBook(newAppointment))
		{
			System.out.println("ALREADY EXISTS");
			return FOUND;//TODO: Throw exception: "ITEM ALREADY EXISTS"
		}
		else
		{
			if(checkForTimeClash(newAppointment) < 0)
				return TIME_CLASH;
			
			appointmentList.add(newAppointment);
			
			DatabaseCommunicator.AddAppointmentToDatabase(appointmentBookName, newAppointment);
			return NOTFOUND;
		}
	}
	
	/**
	 *CONTINUE
	 */
	public void intialiseAppointmentBookFromDatabase()
	{
		appointmentList = DatabaseCommunicator.GetAllAppointmentsFromDatabase(appointmentBookName);
	}
	
	public ArrayList<Appointment> getAllAppointments()
	{
		return appointmentList;
	}
	
	public void showAllAppointments()
	{
		System.out.println(appointmentList.size()+" appointments:");
		for(int i = 0; i < appointmentList.size(); i++)
		{		
			int startDay = 0;
			int startMonth = 0;
			int startYear = 0;
			
			int endDay = 0;
			int endMonth = 0;
			int endYear = 0;
			
			String title = null;
			
			startDay = appointmentList.get(i).getStartDateTime().get(Calendar.DAY_OF_MONTH);
			startMonth = appointmentList.get(i).getStartDateTime().get(Calendar.MONTH);
			startYear = appointmentList.get(i).getStartDateTime().get(Calendar.YEAR);
			
			endDay = appointmentList.get(i).getEndDateTime().get(Calendar.DAY_OF_MONTH);
			endMonth = appointmentList.get(i).getEndDateTime().get(Calendar.MONTH);
			endYear = appointmentList.get(i).getEndDateTime().get(Calendar.YEAR);
			
			title = appointmentList.get(i).getEventTitle();
			
			String output = String.format("%s Starts: %d/%d/%d Ends: %d/%d/%d", title, startDay, startMonth, startYear, endDay, endMonth, endYear);
			
			System.out.println(output);
			
		}
			
	}
	
	public int find(Appointment appointmentToFind)
	{
		for(int i = 0; i < appointmentList.size(); i++)
			if(appointmentList.get(i).toString().contentEquals(appointmentToFind.toString())) //TODO: Needs to be more effective.
				return FOUND;
		return NOTFOUND;
	}
	
	public Appointment findAndReturn(String appointmentName)
	{
		for(int i = 0; i < appointmentList.size(); i++)
			if(appointmentList.get(i).toString().contentEquals(appointmentName)) //TODO: Needs to be more effective.
			{
				System.out.println("CHECK");
				return appointmentList.get(i);
			}
		return null;
	}
	
	public void remove(Appointment appointmentToRemove)
	{
		if(isInBook(appointmentToRemove))
		{
			appointmentList.remove(appointmentToRemove);
			DatabaseCommunicator.RemoveAppointmentFromDatabase(appointmentBookName, appointmentToRemove);
		}
		else
			return;//TODO: Throw exception: "ITEM DOESNT EXIST"
	}
	
	public boolean isInBook(Appointment appointmentToCheck)
	{
		if(find(appointmentToCheck) > 0)
		{
			System.out.println("CHECK");
			return true;
		}
		return false;
	}
	
	public int checkForTimeClash(Appointment appointmentToCheck)
	{
		for(int i = 0; i < appointmentList.size(); i++)
		{
			GregorianCalendar originalStart = appointmentList.get(i).getStartDateTime();
			GregorianCalendar originalEnds = appointmentList.get(i).getEndDateTime();
			
			GregorianCalendar toCheckStart = appointmentToCheck.getStartDateTime();
			GregorianCalendar toCheckEnds = appointmentToCheck.getEndDateTime();
			
			//Starts in the middle of an existing appointment.
			boolean startOverlap = (toCheckStart.after(originalStart) && toCheckStart.before(originalEnds));
			//Ends in the middle of an existing appointment.
			boolean endOverlap = (toCheckEnds.after(originalStart) && toCheckEnds.before(originalEnds));
			//Starts or finishes at the same time as an existing appointment.
			boolean equal = (toCheckStart.compareTo(originalStart) == 0 || toCheckEnds.compareTo(originalEnds)== 0);
			if(startOverlap || endOverlap || equal)
				return TIME_CLASH;
		}
		return NO_TIME_CLASH;
	}
	
	public void SetAppointmentBookName(String name)
	{
		appointmentBookName = name;
	}
	
	public void saveAppointmentsToDatabase()
	{
		for(int i = 0; i < appointmentList.size(); i++)
		{
			DatabaseCommunicator.AddAppointmentToDatabase(appointmentBookName, appointmentList.get(i));
		}
	}
	
	
}
